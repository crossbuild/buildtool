#!/bin/bash
# Embedded Linux Platform Build
# Copyright (C) 2015  Nokia
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
set -eu

export LC_ALL=C

case $0 in
    /*) srcbase=$(dirname $0);;
    *) srcbase=$(dirname $PWD/$0);;
esac
recipes=$srcbase/recipes
src=$srcbase/src

base="$PWD"
obj=$base/builds
states=$base/states
log=$base/logs
pool=$base/pool
tmp=$base/tmp
BUGMAIL='rschiele@gmail.com'
DEFAULTFORMAT="tar.gz"

parallel=-j$(nproc)
haveperl=$(perl -e 'print "1"' 2>/dev/null)

logmsg()
{
    echo "[$(date '+%F %T')] $@"
}

logerr()
{
    logmsg >&2 "$@"
}

forcerm()
{
    rm -rf "$1" 2>/dev/null || chmod -R u+rwx "$1" 2>/dev/null && rm -rf "$1"
}

genhash()
{
    local FILE
    local HEAD
    for FILE in "$@"; do
	FILE=${FILE//\\\[/\[}
	FILE=${FILE//\\\]/\]}
	FILE=${FILE/<SOURCE>/$src}
	FILE=${FILE/<RECIPE>/$recipes}
	FILE=${FILE/<STATE>/$states}
	FILE=${FILE/<POOL>/$pool}
	case "$FILE" in
	    *\[*\])
		HEAD=${FILE/*\[}
		HEAD=${HEAD/\]}
		echo "$HEAD $FILE"
		continue
		;;
	esac
        if test -f $FILE; then
            sha1sum $FILE
        elif test -e $FILE/.git; then
            (
		flock -s 200
                cd $FILE
		if test "$dirty" && test "$(git status --porcelain -uall)"; then
		    sha1sum $(git status --porcelain -uall | awk '{print $2}') 2>&1 |
		    sha1sum | sed -e "s|[[:space:]].*| $FILE|"
		else
		    git show-ref --head | sed -ne 's| HEAD$| '"$FILE"'|p'
		fi
	    ) 200>"$states/_lock/src/$(basename "$FILE")"
        elif test -f $FILE/.gitcommitid; then
            sed -ne 's|$| '"$FILE"'|p' $FILE/.gitcommitid
	else
	    case $FILE in
		$src/*)
		    (
			cd $srcbase
			git cat-file -p HEAD:src |
			sed -ne "s|^160000 commit \(.\{40\}\).\(${FILE/$src\/}\)\$|\1 <SOURCE>/\2|p"
		    )
		    ;;
		*)
		    echo "efefefefefefefefefefefefefefefefefefefef $FILE"
		    ;;
	    esac
        fi
    done | sed -e "s|  *$src/| <SOURCE>/|
		   s|  *$recipes/| <RECIPE>/|
		   s|  *$states/| <STATE>/|
		   s|  *$pool/| <POOL>/|"
}

srcvers()
{
    local FILE="$1"
    local HEAD="$2"
    if test -e $FILE/.git; then
	(
	    cd $FILE
	    git describe --always --tags --match '_release/*' "$HEAD" | sed -e 's|^_release/||'
	)
    elif test -f $FILE/.gitversion; then
	cat $FILE/.gitversion
    else
	echo unknown
    fi
}

makelist()
{
    local FILE="$(echo "$1" | sed -e 's|/*$||')"
    local PARAM="$2"
    local OPT="$3"
    find $destdir$RELOC$FILE $PARAM 2>/dev/null | sed -e "s|^$destdir||" | grep -v '^'"$RELOC"'$' | LC_ALL=C sort >> $tmp/list.$PKG
    if test "$OPT" != 1 -a ${PIPESTATUS[0]} != 0; then
	logerr "$PKG: $FILE: No such file or directory"
	false
    fi
}

newpkg()
{
    PKG="$(eval "echo $1")"
    RELOC="$(eval "echo $2")"
    PKGS[${#PKGS[@]}]="$PKG"
    PKGLIST[${#PKGLIST[@]}]="$tmp/list.$PKG"
    RELOCS[${#RELOCS[@]}]="$RELOC"
    AUTO[${#AUTO[@]}]=
    NOHASH[${#NOHASH[@]}]=0
    FORMAT[${#FORMAT[@]}]="$DEFAULTFORMAT"
    rm -f $tmp/list.$PKG $pool/$PKG.newmeta
    touch $tmp/list.$PKG $pool/$PKG.newmeta
    genhash $states/$target/$recipe/hash | sed -e 's|/hash$|/done|' > $pool/$PKG.newmeta
    cat "$blddir/.meta" >> $pool/$PKG.newmeta
}

comp()
{
    local REF="$1"
    local ERRSTR="$2"
    diff "$REF" <(LC_ALL=C sort -u "${PKGLIST[@]}") | sed -ne 's|^< ||p' > $tmp/list.err
    if test ${PIPESTATUS[0]} != 0; then
	logerr "$ERRSTR"
	cat >&2 $tmp/list.err
	rm $tmp/list.err
	false
    fi
    rm $tmp/list.err
}

hashfilelist()
{
    local filetohash
    local tmpdir
    local abspath
    cd $1
    while read filetohash; do
	echo "$filetohash"
	stat -c %f "$filetohash"
	if test -h "$filetohash"; then
	    readlink "$filetohash" | sha1sum | sed -e 's| .*||'
	elif test -f "$filetohash"; then
	    case "$filetohash" in
		*.a)
		    tmpdir=$(mktemp -d)
		    abspath="$PWD/$filetohash"
		    (
			cd "$tmpdir"
			ar x "$abspath"
			find . | sort | hashfilelist $PWD
		    )
		    forcerm "$tmpdir"
		    ;;
		*.tar|*.cpio|*.gz|*.tgz|*.bz2|*.tbz|*.tbz2|*.tb2|*.Z|*.taz|*.lz|*.lzma|*.tlz|*.xz|*.txz)
		    tmpdir=$(mktemp -d)
		    cat "$filetohash" |
		    case "$filetohash" in
			*.tar|*.cpio)
			    cat
			    ;;
			*.gz|*.tgz)
			    gzip -cd
			    ;;
			*.bz2|*.tbz|*.tbz2|*.tb2)
			    bzip2 -cd
			    ;;
			*.Z|*.taz)
			    compress -cd
			    ;;
			*.lz|*.lzma|*.tlz)
			    lzma -cd
			    ;;
			*.xz|*.txz)
			    xz -cd
			    ;;
		    esac |
		    case "$filetohash" in
			*.tar|*.tar.gz|*.tar.bz2|*.tar.Z|*.tar.lz|*.tar.lzma|*.tar.xz|*.tgz|*.tbz|*.tbz2|*.tb2|*.taz|*.tlz|*.txz)
			    (
				cd "$tmpdir"
				tar -x -k -p
				find . | sort | hashfilelist $PWD
			    )
			    ;;
			*.cpio|*.cpio.gz|*.cpio.bz2|*.cpio.Z|*.cpio.lz|*.cpio.lzma|*.cpio.xz)
			    (
				cd "$tmpdir"
				cpio -imd --quiet
				find . | sort | hashfilelist $PWD
			    )
			    ;;
			*.gz|*.bz2|*.Z|*.lz|*.lzma|*.xz)
			    sha1sum | sed -e 's| .*||'
			    ;;
		    esac
		    forcerm "$tmpdir"
		    ;;
		*)
		    sha1sum "$filetohash" | sed -e 's| .*||'
		    ;;
	    esac
	fi
    done | sha1sum | sed -e 's| .*||'
}

package()
{
    mkdir -p $pool $tmp
    local PKG
    local RELOC
    local T1
    local T2
    local FILE
    local RELOCINP
    local PKGS=()
    local RELOCS=()
    local PKGLIST=()
    local AUTO=()
    local NOHASH=()
    local FORMAT=()
    newpkg full ''
    makelist '' '' 0
    PKGS=()
    RELOCS=()
    PKGLIST=()
    AUTO=()
    NOHASH=()
    FORMAT=()
    rm -f "$states/$target/$recipe/packages" "$states/$target/$recipe/nocache"
    while read T1 T2 FILE RELOCINP; do
	if test "$T1" = '#|pkg'; then
	    case "$T2" in
		name)
		    newpkg $FILE "$RELOCINP"
		    ;;
		'+')
		    makelist "$FILE" '' 0
		    ;;
		'.')
		    makelist "$FILE" '-maxdepth 0' 0
		    ;;
		'+?')
		    makelist "$FILE" '' 1
		    ;;
		'.?')
		    makelist "$FILE" '-maxdepth 0' 1
		    ;;
		dep)
		    echo dep "$(eval "echo $FILE $RELOCINP")" >> $pool/$PKG.newmeta
		    ;;
		auto)
		    AUTO[${#AUTO[@]}-1]="$(eval "echo $FILE")"
		    ;;
		nohash)
		    NOHASH[${#NOHASH[@]}-1]=1
		    ;;
		format)
		    FORMAT[${#FORMAT[@]}-1]="$(eval "echo $FILE")"
		    case "$FORMAT[${#FORMAT[@]}-1]" in
			plain)
			    touch "$states/$target/$recipe/nocache"
			    ;;
		    esac
		    ;;
		nocache)
		    touch "$states/$target/$recipe/nocache"
		    ;;
		*)
		    echo "Unknown package tag: $T2".
		    exit 1
		    ;;
	    esac
	fi
    done
    # remove phantoms created by symlinks
    for ((NUM=0; NUM < ${#PKGS[@]}; ++NUM)); do
	diff $tmp/list.full <(LC_ALL=C sort "${PKGLIST[NUM]}") |
	sed -ne 's|> ||p' |
	diff - <(LC_ALL=C sort "${PKGLIST[NUM]}") |
	sed -ne 's|> ||p' > $tmp/list.tmp
	mv $tmp/list.tmp "${PKGLIST[NUM]}"
    done
    comp <(LC_ALL=C sort "${PKGLIST[@]}") "Packaged twice:"
    comp $tmp/list.full "Not packaged:"
    rm -f $tmp/list.full $pool/full.newmeta $pool/nopackage.newmeta
    for ((NUM=0; NUM < ${#PKGS[@]}; ++NUM)); do
	if test ${PKGS[NUM]} != nopackage; then
	    logmsg packaging ${PKGS[NUM]} ${RELOCS[NUM]}
	    echo "format ${FORMAT[NUM]}" >> $pool/${PKGS[NUM]}.newmeta
	    test "${AUTO[NUM]}" &&
	    while read FILE; do
		readelf -d "$destdir$FILE" 2>/dev/null |
		sed -ne 's|\.|-|g
			 s|^ 0x0*1 .*\[\(lib.*\).so\(-.*\)\]$|dep '"${AUTO[NUM]}"'-\1\2|p
			 s|^ 0x0*1 .*\[ld.*$|dep '"${AUTO[NUM]}"'-libc-6|p'
		case "$FILE" in
		    ${RELOCS[NUM]}/usr/lib/lib*.so|\
		    ${RELOCS[NUM]}/usr/lib64/lib*.so)
			readelf -d "$destdir$FILE" 2>/dev/null |
			sed -ne 's|\.|-|g
				 s|^ 0x0*e .*\[\(lib.*\).so\(-.*\)\]$|dep '"${AUTO[NUM]}"'-\1\2|p
				 s|^ 0x0*e .*\[ld.*$|dep '"${AUTO[NUM]}"'-libc-6|p'
			;;
		esac
	    done < ${PKGLIST[NUM]} | sort -u >> $pool/${PKGS[NUM]}.newmeta
	    rm -f "$pool/${PKGS[NUM]}.${FORMAT[NUM]}"
	    if test "${NOHASH[NUM]}" = 1 || test "${FORMAT[NUM]}" = plain; then
		echo nohash $(date +%s.%N | sha1sum | awk '{print $1}')
	    else
		echo payload $(sed -e 's|^'"${RELOCS[NUM]}"'/||' ${PKGLIST[NUM]} |
			hashfilelist $destdir${RELOCS[NUM]})
	    fi >> $pool/${PKGS[NUM]}.newmeta
	    case "${FORMAT[NUM]}" in
		tar|tar.*|tgz|tbz|tbz2|tb2|taz|tlz|txz|plain)
		    tar -c -C $destdir${RELOCS[NUM]} --no-recursion --owner=0 --group=0 -T <(sed -e 's|^'"${RELOCS[NUM]}"'/||' ${PKGLIST[NUM]})
		    ;;
		cpio|cpio.*)
		    sed -e 's|^'"${RELOCS[NUM]}"'/||' ${PKGLIST[NUM]} |
		    (
			cd $destdir${RELOCS[NUM]}
			cpio -o -R 0:0 -H newc --quiet
		    )
		    ;;
		*)
		    logerr "Unsupported file format: ${FORMAT[NUM]}"
		    exit 1
		    ;;
	    esac |
	    case "${FORMAT[NUM]}" in
		tar|cpio|plain)
		    cat
		    ;;
		*.gz|tgz)
		    gzip -cn9
		    ;;
		*.bz2|tbz|tbz2|tb2)
		    bzip2 -c9
		    ;;
		*.Z|taz)
		    compress -c
		    ;;
		*.lz|*.lzma|tlz)
		    lzma -c9
		    ;;
		*.xz|txz)
		    xz -c9 --check=crc32 --lzma2=dict=1MiB
		    ;;
		*)
		    logerr "Unsupported file format: ${FORMAT[NUM]}"
		    exit 1
		    ;;
	    esac |
	    case "${FORMAT[NUM]}" in
		plain)
		    rm -rf $base/plain/${PKGS[NUM]}
		    mkdir -p $base/plain/${PKGS[NUM]}
		    tar -C $base/plain/${PKGS[NUM]} -x -k -p
		    rm $pool/${PKGS[NUM]}.newmeta
		    ;;
		*)
		    cat > "$pool/${PKGS[NUM]}.${FORMAT[NUM]}"
		    mv $pool/${PKGS[NUM]}.newmeta $pool/${PKGS[NUM]}.meta
		    ;;
	    esac
	    echo ${PKGS[NUM]} >> "$states/$target/$recipe/packages"
	fi
    done
    logmsg Packaging successfully completed.
}

resolve_ins_getdeps()
{
		case "$PKG" in
		    \[*\])
			;;
		    *)
			sed -ne 's|^dep ||p' $pool/$PKG.meta |
			while read PKG2 RELOC2; do
			    echo $PKG2 $RELOC$RELOC2
			done
			;;
		esac
}

resolve_ins()
{
    local T1
    local PKG
    local RELOC
    local PKG2
    local RELOC2
    local noblock=$1

    > $tmp/metatmp
    > $tmp/metablk
    while read T1 PKG RELOC; do
	PKG="${PKG//[/\[}"
	PKG="${PKG//]/\]}"
	if test "$T1" = '#|ins'; then
	    echo "$(eval "echo $PKG $RELOC")" >> $tmp/metatmp
	fi
	if test "$noblock" != 1; then
	    if test "$T1" = '#|blk'; then
		echo "$(eval "echo $PKG $RELOC")" >> $tmp/metablk
	    fi
	    if test "$T1" = '#|blkbase'; then
		sed -ne "s|^[0-9a-f]* <POOL>/\(.*\)\.meta\$|\1 $RELOC|p" $states/$target/$PKG/done >> $tmp/metablk
	    fi
	fi
    done

    while true; do
	cp $tmp/metatmp $tmp/metaold
	diff <(
	    while read PKG RELOC; do
		echo "$PKG" $RELOC
		resolve_ins_getdeps
	    done < $tmp/metaold | LC_ALL=C sort -u
	) <(
	    LC_ALL=C sort -u $tmp/metablk
	) | sed -ne 's|< ||p' > $tmp/metatmp
	diff $tmp/metaold $tmp/metatmp >/dev/null 2>/dev/null && break
    done

    if test "$noblock" = 1; then
	sed -e 's|^\[\([^]]*\)\]|\1|' $tmp/metatmp
    else
	cat $tmp/metatmp
    fi

    rm $tmp/metatmp $tmp/metaold $tmp/metablk
}

installer()
{
    local PKG
    local RELOC
    local FORMAT

    forcerm $srcdir
    mkdir -p $srcdir/.meta
    resolve_ins 0 |
    while read PKG RELOC; do
	logmsg "installing $PKG $RELOC"
	case "$PKG" in
	    \[*\])
		PKG=$(echo "$PKG" | sed -e 's|^\[\([^]]*\)\]|\1|')
		FORMAT=$(sed -ne 's|^format ||p' $pool/$PKG.meta)
		test "$FORMAT" || FORMAT="$DEFAULTFORMAT"
		cp $pool/$PKG.meta $srcdir/.meta
		case "$RELOC" in
		    /*) RELOC="$srcdir$RELOC";;
		    *) RELOC="$blddir/$RELOC";;
		esac
		case "$RELOC" in
		    */) RELOC="$RELOC$PKG.$FORMAT";;
		esac
		mkdir -p $(dirname $RELOC)
		cp $pool/$PKG.$FORMAT $RELOC
		;;
	    *)
		FORMAT=$(sed -ne 's|^format ||p' $pool/$PKG.meta)
		test "$FORMAT" || FORMAT="$DEFAULTFORMAT"
		cp $pool/$PKG.meta $srcdir/.meta
		mkdir -p $srcdir$RELOC
		cat $pool/$PKG.$FORMAT |
		case "$FORMAT" in
		    tar|cpio)
			cat
			;;
		    *.gz|tgz)
			gzip -cd
			;;
		    *.bz2|tbz|tbz2|tb2)
			bzip2 -cd
			;;
		    *.Z|taz)
			compress -cd
			;;
		    *.lz|*.lzma|tlz)
			lzma -cd
			;;
		    *.xz|txz)
			xz -cd
			;;
		    *)
			logerr "Unsupported file format: $FORMAT"
			exit 1
			;;
		esac |
		case "$FORMAT" in
		    tar|tar.*|tgz|tbz|tbz2|tb2|taz|tlz|txz)
			tar -C $srcdir$RELOC -x -k -p
			;;
		    cpio|cpio.*)
			(
			    cd $srcdir$RELOC
			    cpio -imd --quiet
			)
			;;
		    *)
			logerr "Unsupported file format: $FORMAT"
			exit 1
			;;
		esac
		;;
	esac
    done
    logmsg Installation of requirements successfully completed.
}

getrecipe()
{
    local recipe=$1
    local target=$2

    if test -r $recipes/${recipe}_$target; then
        echo $recipes/${recipe}_$target
    elif test -r $recipes/$recipe; then
        echo $recipes/$recipe
    fi
}

srcinstaller()
{
    local SRC
    local DIR
    local PTH
    local srcdst
    local HEAD
    rm -f "$blddir/.meta"
    touch "$blddir/.meta"
    awk '/^#\|src /{ print $2" "$3 }' |
    while read SRC PTH; do
	logmsg installing sources $SRC $PTH
	case "$SRC" in
	    *\[*\])
		HEAD=${SRC/*\[}
		HEAD=${HEAD/\]}
		DIR=${SRC/\[*\]}
		;;
	    *)
		HEAD=HEAD
		DIR=$SRC
		;;
	esac
	case "$PTH" in
	    //none) continue;;
	    /*) srcdst="$srcdir$PTH";;
	    *) srcdst="$blddir/$PTH";;
	esac
	mkdir -p "$srcdst"
	(
	    flock -x 200
	    if ! test "$(ls -A $src/$DIR)"; then
		cd $srcbase
		git submodule update src/$DIR
	    fi
	) 200>"$states/_lock/src/$DIR"
	(
	    flock -s 200
	    cd $src/$DIR
	    if test -e .git && ( test -z "$dirty" || test "$HEAD" != HEAD ||
		test -z "$(git status --porcelain -uall)" ); then
		git archive --format=tar "$HEAD"
	    else
		tar -c --exclude=./.git .
	    fi
	) 200>"$states/_lock/src/$DIR" |
	tar -C "$srcdst" -x -k
	echo src $(genhash $src/$SRC)-$(srcvers $src/$DIR "$HEAD") |
	sed -e 's|<SOURCE>/||;s|\[.*\]||' >> "$blddir/.meta"
    done
}

exithandler()
{
    if ! test -f "$states/$target/$recipe/done"; then
	cat <<EOT
>>>
>>> Building of $recipe for target $target failed.
>>>
EOT
	if ! test "$verbose"; then
	    gzip -cd < "$log/$target-$recipe.log.gz"
	fi
    fi
}

logger()
{
    local logfile="$1"
    rm -f "$logfile"
    if test "$verbose"; then
	tee >(gzip -c9 > "$logfile")
    else
	gzip -c9 > "$logfile"
    fi
}

listarchs()
{
    (
	echo all
	sed -ne 's/^#|dep \+.* \+//p' $recipes/*
    ) | sort -u
}

listpkgs()
{
    local ARCHS=$(listarchs)
    local ARCHSED=
    local target
    local recipe
    for target in $ARCHS; do
	if test "$ARCHSED"; then
	    ARCHSED="$ARCHSED\|$target"
	else
	    ARCHSED="$target"
	fi
    done
    for recipe in $(ls $recipes); do
	echo $recipe | sed -e "s,_\($ARCHSED\)\$,,"
    done | sort -u
}

calcdeps_perl()
{
    local ARCHS=$(listarchs)
    local PKGS=$(listpkgs)
    local target
    local recipe
    cat <<'EOT'
ifneq ($(BUILD),echo)
T := $(shell $(MAKE) $(MAKECMDGOALS) --no-print-directory \
	-rRf $(firstword $(MAKEFILE_LIST)) \
	BUILD=echo PROGRESS=X | wc -l)
N := x
C = $(words $N)$(eval N := x $N)
PROGRESS = `expr $C '*' 100 / $T`
endif
EOT
    export recipe
    export target
    rm -rf states/.file[0-9]*
    N=1
    WAIT=0
    for recipe in $PKGS; do
        N=$(expr $N + 1)
        WAIT=$(expr $WAIT + 1)
        NF=states/.file"$(printf %05d $N)"
	{
	    perl -we '
		use strict;

		my $recipe='\'"$recipe"\'';
		my $recipes='\'"$recipes"\'';
		my @ARCHS=qw('"$ARCHS"');
		for my $target (@ARCHS) {

		    print << "EOT" ;
.PHONY: $target/$recipe
$target/$recipe:
	\@\+\$(BUILD) --progress="\$(PROGRESS)" --build-internal $recipe $target
EOT
		    my $file="$recipes/${recipe}_${target}";
		    $file = "$recipes/${recipe}" unless -f $file;
		    if (-f "$file") {

			my $dep="";
			my $ins="";
			my $bas="";
			my $nam="";
			my $pkd="";

			my $pkgname=undef;
			open(my $fd,$file) or die "$file: $!, stopped";
			while (<$fd>) {
			    if (/^\#\|dep\s+(\S+)\s*(\S*)/) {
				my ($pkg,$tgt)=($1,$2);
				$tgt = $target if $tgt eq "";
				if ($pkg ne "auto") {
				    $dep .= "$target/$recipe: $tgt/$pkg\n";
				}
			    } elsif (/^\#\|ins\s+\[?([^]\s]+)\]?/) {
				#my $pkg="_PKG/" . `echo $1`;
				my $pkg="_PKG/$1";
				$pkg =~ s/\$target/$target/g;
				$pkg =~ s/\$\{target\}/$target/g;
				chomp($pkg);
				$ins .= ".PHONY: $pkg\n";
				$ins .= "$target/$recipe: $pkg\n";
				$ins .= "$pkg:\n";
			    } elsif (/^\#\|blkbase\s+(\S+)/) {
				$bas .= "$target/$recipe: $target/$1\n";
			    } elsif (/^\#\|pkg name\s+(\S+)/) {
				if ($1 ne "nopackage") {
				    #$pkgname="_PKG/" . `echo $1`;
				    $pkgname="_PKG/$1";
				    $pkgname =~ s/\$target/$target/g;
				    $pkgname =~ s/\$\{target\}/$target/g;
				    chomp($pkgname);
				    $nam .= ".PHONY: $pkgname\n";
				    $nam .= "$pkgname: $target/$recipe #GEN\n";
				} else {
				    $pkgname="_PKG/nopackage";
				    $pkgname =~ s/\$target/$target/g;
				    $pkgname =~ s/\$\{target\}/$target/g;
				}
			    } elsif (/^\#\|pkg dep\s+(\S+)/) {
				#my $pkgd="_PKG/" . `echo $1`;
				my $pkgd="_PKG/$1";
				$pkgd =~ s/\$target/$target/g;
				$pkgd =~ s/\$\{target\}/$target/g;
				chomp($pkgd);
				$pkd .= ".PHONY: $pkgd\n";
				$pkd .= "$pkgname: $pkgd\n";
				$pkd .= "$pkgd:\n";
			    }
			} # while
			close $fd;
			print "$dep$ins$bas$nam$pkd";
		    } # if
		} # for
	    '
        } >$NF &
	if test $WAIT -ge $(nproc); then
	    wait
	    WAIT=0
	    cat states/.file[0-9]*
	    rm -rf states/.file[0-9]*
	fi
    done
    if test $WAIT -gt 0; then
	wait
	WAIT=0
	cat states/.file[0-9]*
	rm -rf states/.file[0-9]*
    fi
}

calcdeps_bash()
{   
    local ARCHS=$(listarchs)
    local target
    local recipe
    local file
    local PKGS=$(listpkgs)
    local PKG
    local PKGD
    local TGT
    cat <<'EOT'
ifneq ($(BUILD),echo)
T := $(shell $(MAKE) $(MAKECMDGOALS) --no-print-directory \
	-rRf $(firstword $(MAKEFILE_LIST)) \
	BUILD=echo PROGRESS=X | wc -l)
N := x
C = $(words $N)$(eval N := x $N)
PROGRESS = `expr $C '*' 100 / $T`
endif
EOT
    for recipe in $PKGS; do
	for target in $ARCHS; do
	    cat <<EOT
.PHONY: $target/$recipe
$target/$recipe:
	@+\$(BUILD) --progress="\$(PROGRESS)" --build-internal $recipe $target
EOT
	    file=$(getrecipe $recipe $target)
	    if test "$file"; then
		awk '/^#\|dep /{if ($3) { print $2" "$3 }
				else    { print $2" '"$target"'" }}' $file |
		while read PKG TGT; do
		    test "$PKG" = auto || echo $target/$recipe: $TGT/$PKG
		done
		grep '^#|ins ' $file | while read A B C; do
		    B=$(echo "$B" | sed -e 's|^\[\([^]]*\)\]|\1|')
		    PKG=_PKG/$(eval echo $B)
		    echo ".PHONY: $PKG"
		    echo "$target/$recipe: $PKG"
		    echo "$PKG:"
		done
		grep '^#|blkbase ' $file | while read A B C; do
		    echo $target/$recipe: $target/$B
		done
		grep '^#|pkg name ' $file | while read A B C D; do
		    if test "$C" != nopackage; then
			PKG=_PKG/$(eval echo $C)
			echo ".PHONY: $PKG"
			echo "$PKG: $target/$recipe #GEN"
		    fi
		done
		awk '/^#\|pkg name/{a=$3}/^#\|pkg dep/{print a" "$3}' $file |
		while read A B; do
		    PKG=_PKG/$(eval echo $A)
		    PKGD=_PKG/$(eval echo $B)
		    echo ".PHONY: $PKGD"
		    echo "$PKG: $PKGD"
		    echo "$PKGD:"
		done
	    fi
	done
    done
}

calcdeps()
{
    if test "$haveperl"; then
	calcdeps_perl
    else
	calcdeps_bash
    fi
}

publishpackage()
{
    local target=$1
    local recipe=$2
    local HASHPOOL=$PKGPOOL/.hashpool
    local MANIFESTDIR=$PKGPOOL/.manifest
    local MANIFEST=$(hostname).$target-$recipe.$(date +%s).$$
    local hash="$target/$recipe/$(sha1sum "$states/$target/$recipe/done" |
	sed -e 's|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\).*|\1/\2|')"
    local cmd
    local pkg
    if ! test -r "$states/$target/$recipe/nocache" &&
	! test -d "$HASHPOOL/$hash"; then
	cmd="mkdir -p $HASHPOOL/$hash.$MANIFEST &&
	    cp $log/$target-$recipe.log.gz $HASHPOOL/$hash.$MANIFEST/.log.gz"
	for pkg in $(<"$states/$target/$recipe/packages"); do
	    local FORMAT=$(sed -ne 's|^format ||p' "$pool/$pkg.meta")
	    test "$FORMAT" || FORMAT="$DEFAULTFORMAT"
	    cmd="$cmd && cp $pool/$pkg.meta $HASHPOOL/$hash.$MANIFEST/$pkg.meta &&
		cp $pool/$pkg.$FORMAT $HASHPOOL/$hash.$MANIFEST/$pkg.$FORMAT"
	done
	cmd="$cmd && ( mv -T $HASHPOOL/$hash.$MANIFEST $HASHPOOL/$hash &&
	    mkdir -p $MANIFESTDIR &&
	    echo $HASHPOOL/$hash > $MANIFESTDIR/$MANIFEST.done ||
	    rm -rf $HASHPOOL/$hash.$MANIFEST )"
	if test "$(id -un)" != "$releaseuser"; then
	    ssh -o NoHostAuthenticationForLocalhost=yes \
		"$releaseuser"@localhost "$cmd"
	else
	    echo "$cmd" | bash
	fi
    fi
}

publishdepmake()
{
    local HASHPOOL=$PKGPOOL/.hashpool
    local MANIFESTDIR=$PKGPOOL/.manifest
    local MANIFEST=$(hostname)._depmake.$(date +%s).$$
    local hash=$(echo $recipesum |
	sed -e 's|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\)$|_depmake/\1/\2|')
    local cmd
    if ! test -d "$HASHPOOL/$hash"; then
	cmd="mkdir -p $HASHPOOL/$hash.$MANIFEST &&
	    cp $states/_depmake $HASHPOOL/$hash.$MANIFEST/_depmake &&
	    ( mv -T $HASHPOOL/$hash.$MANIFEST $HASHPOOL/$hash &&
	    mkdir -p $MANIFESTDIR &&
	    echo $HASHPOOL/$hash > $MANIFESTDIR/$MANIFEST.done ||
	    rm -rf $HASHPOOL/$hash.$MANIFEST )"
	if test "$(id -un)" != "$releaseuser"; then
	    ssh -o NoHostAuthenticationForLocalhost=yes \
		"$releaseuser"@localhost "$cmd"
	else
	    echo "$cmd" | bash
	fi
    fi
}

invoke()
{
    local recipe="$1"
    shift
    local target="$1"
    shift
    local file
    local lfile
    local settings
    local hashes
    local oldrecipes
    local usedrecipes
    local pkg
    local pkghash
    local srcdir=$obj/$target/$recipe/srcdir
    local blddir=$obj/$target/$recipe/build
    local destdir=$obj/$target/$recipe/destdir
    mkdir -p $states/_lock/src
    if ! test -r "$states/$target/$recipe/done" ||
	! diff "$states/$target/$recipe/done" <(genhash $(awk '{print $2}' "$states/$target/$recipe/done" || true)
	) > /dev/null 2> /dev/null; then
        mkdir -p "$states/$target/$recipe"
	settings=$(getrecipe settings $target)
	file=$(getrecipe $recipe $target)
        if test "$file" = ""; then
	    logerr "Nothing known about $recipe on $target."
	    return 1
	fi
	usedrecipes="$settings $file"
	oldrecipes=
	while test "$oldrecipes" != "$usedrecipes"; do
	    oldrecipes="$usedrecipes"
            usedrecipes="$( ( for h in $usedrecipes; do echo $h; done; awk '
	    /^[^#]/{
		sub(/\$target/, "'"$target"'", $0);
		while (match($0, /\$recipes\/[^[:space:]()$]+/)) {
		    p = substr($0, RSTART, RLENGTH);
		    sub(/\$recipes\//, "'"$recipes"'/", p);
		    print p;
		    $0 = substr($0, RSTART + RLENGTH);
		}
	    }' $usedrecipes ) | sort -u)"
        done
	local tmp=$obj/$target/$recipe/tmp
	mkdir -p $tmp
        hashes="$(for h in $usedrecipes $recipes/settings_$target $recipes/${recipe}_$target; do
		echo $h; done | sort -u) $(resolve_ins 1 < $file |
	    sed -e "s|^\([^ ]*\).*|$pool/\1.meta|") $(awk '
            /^#\|src /{ print "'"$src"'/"$2 } ' $usedrecipes)"
	forcerm $tmp
	rm -f "$states/$target/$recipe/done"
	genhash ${hashes//\[/\\\[} > "$states/$target/$recipe/hash"
	local pkghash=$(sha1sum "$states/$target/$recipe/hash" | sed -e "s|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\) .*|$target/$recipe/\1/\2|")
	if test "$prepopulate" != no -a -d "$PKGPOOL/.hashpool/$pkghash"; then
	    logmsg "$(printf '[%3u%%]' $progress) Retrieving $target/$recipe"
	    mkdir -p $pool "$log"
	    rm -f "$states/$target/$recipe/packages" "$states/$target/$recipe/nocache"
	    for pkg in $PKGPOOL/.hashpool/$pkghash/*; do
		if test -r "$pkg"; then
		    rm -f "$pool/$(basename $pkg)"
		    $prepopulatebin "$pkg" "$pool/"
		    case "$pkg" in
			*.meta)
			    echo $(basename $pkg .meta) >> "$states/$target/$recipe/packages"
			    ;;
		    esac
		fi
	    done
	    if test -r $PKGPOOL/.hashpool/$pkghash/.log.gz; then
		rm -f "$log/$target-$recipe.log.gz"
		$prepopulatebin $PKGPOOL/.hashpool/$pkghash/.log.gz "$log/$target-$recipe.log.gz"
	    fi
	    mv "$states/$target/$recipe/hash" "$states/$target/$recipe/done"
	else
	    logmsg "$(printf '[%3u%%]' $progress) Building $target/$recipe"
	    forcerm "$obj/$target/$recipe"
	    mkdir -p "$blddir" "$log"
	    mkdir -p -m 00755 $destdir
            trap exithandler 0
	    set -o pipefail
            (
		set +o pipefail
		tmp="$blddir/.pkg"
		mkdir "$tmp"
		installer < $file
		cat $usedrecipes | srcinstaller
		forcerm "$tmp"
		PS4='+ \D{%F %T} \w> '
		cd "$blddir"
		(
		    set -x
		    for lfile in $settings $file; do
			. "$lfile"
		    done
		    touch "$blddir/.success"
		)
		test -r "$blddir/.success"
		mkdir -p "$tmp"
		touch "$tmp/dynamic"
		grep -h '^#|' $file "$tmp/dynamic" | package
		mv "$states/$target/$recipe/hash" "$states/$target/$recipe/done"
            ) 2>&1 | logger "$log/$target-$recipe.log.gz"
	    set +o pipefail
	    trap '' 0
	    exithandler
	    test -f "$states/$target/$recipe/done"
	    if ! test "$keepbuilds"; then
		forcerm "$obj/$target/$recipe"
	    fi
	fi
	test "$release" && publishpackage $target $recipe || true
    fi
}

purgebuilds()
{
    logmsg Purging build directories
    forcerm $obj
}

purgepool()
{
    local FILE
    local BASE
    local pkg

    logmsg Purging pool

    diff <(
	for pkg in $pool/*.meta; do
	    local STATEFILE=$(head -n 1 $pkg |
		sed -e "s|.* <STATE>|$states|")
	    if test -r "$STATEFILE" -a \
		"$(sha1sum "$STATEFILE" | awk '{print $1}')" = \
		"$(head -n 1 $pkg | awk '{print $1}')"; then
		echo $pkg
		BASE=$pool/$(basename $pkg .meta)
		(
		    sed -ne "s|^format |$BASE.|p" $pkg
		    echo $BASE.tar.gz
		) | head -n 1
	    fi
	done | sort
	) <(ls -d $pool/* | sort) |
    sed -ne 's|^> ||p' |
    while read FILE; do
	rm $FILE
    done
}

publish()
{
    local HASHPOOL=$PKGPOOL/.hashpool
    local RELEASE=$1
    local RELEASEDIR=
    local RELLINK=../.hashpool
    local recipe

    if test "$(id -un)" != "$releaseuser"; then
	ssh -o NoHostAuthenticationForLocalhost=yes "$releaseuser"@localhost \
	    "cd $base && $srcbase/$(basename $0) --pkgpool $PKGPOOL --releaseuser $releaseuser --publish-internal $RELEASE"
	exit 0
    fi

    if test "$RELEASE" != .; then
	if test -d $PKGPOOL/$RELEASE; then
	    logerr "Release $RELEASE exists already."
	    exit 1
	fi
	RELEASEDIR=$PKGPOOL/$RELEASE
	mkdir -p $RELEASEDIR.tmp
    fi

    for recipe in $states/*/*/packages; do
	local recipedir=$(dirname $recipe)
	if test -r $recipe && ! test -r $recipedir/nocache; then
	    local firstpkg=$(head -n 1 $recipe)
	    if test "$firstpkg"; then
		local fullmeta=$pool/$firstpkg.meta
		logmsg publishing $(sed -e 's|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\) <STATE>/\(.*\)/\(.*\)/done$|\3/\4|;q' $fullmeta)
		publishpackage $(sed -e 's|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\) <STATE>/\(.*\)/\(.*\)/done$|\3 \4|;q' $fullmeta)
		if test "$RELEASEDIR"; then
		    local hash=$(sed -e 's|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\) <STATE>/\(.*\)/\(.*\)/done$|\3/\4/\1/\2|;q' $fullmeta)
		    for pkg in $HASHPOOL/$hash/*; do
			ln -s $RELLINK/$hash/$(basename $pkg) $RELEASEDIR.tmp/
		    done
		    test -h $HASHPOOL/$hash/.needed.$RELEASE || ln -s ../../../../../$RELEASE $HASHPOOL/$hash/.needed.$RELEASE
		fi
	    fi
	fi
    done

    logmsg buildcache published
    if test "$RELEASEDIR"; then
	touch $RELEASEDIR.tmp/.backlinked
	(
	    cd $srcbase
	    echo ${RELEASE}
	    git rev-parse HEAD
	) > $RELEASEDIR.tmp/version
	mv -T $RELEASEDIR.tmp $RELEASEDIR
	local MANIFESTDIR=$PKGPOOL/.manifest
	local MANIFEST=$MANIFESTDIR/$(hostname).$(date +%s).$$
	mkdir -p $MANIFESTDIR
	echo $RELEASEDIR > $MANIFEST.done
	logmsg release ${RELEASE} complete
    fi
}

garbagecollect_listold()
{
    if test -d "$1" && (( $(stat -c %Y "$1") < LIMIT )); then
	echo "$1"
    fi
}

garbagecollect_list()
{
    local arch
    local pkg
    local inst
    local ref
    local target="$1"
    local recipe="$2"
    local LIMIT="$(($(date +%s)-60*60*24*$3))"

    test "$target" != all || unset target
    test "$recipe" != all || unset recipe

    for arch in $PKGPOOL/.hashpool/${target-*}; do
	case "$arch" in
	    */_depmake)
		for inst in $arch/*/*; do
		    garbagecollect_listold $inst
		done
		;;
	    *)
		for pkg in $arch/${recipe-*}; do
		    for inst in $pkg/*/*; do
			for ref in $inst/.needed.*; do
			    test -e $ref && continue 2
			done
			garbagecollect_listold $inst
		    done
		done
		;;
	esac
    done
}

garbagecollect()
{
    local target="$1"
    local recipe="$2"
    local garbagecollectdays="$3"

    if test "$(id -un)" != "$releaseuser"; then
	ssh -o NoHostAuthenticationForLocalhost=yes "$releaseuser"@localhost \
	    "cd $base && $srcbase/$(basename $0) --pkgpool $PKGPOOL --releaseuser $releaseuser --garbagecollect=$garbagecollectdays $recipe $target"
	exit 0
    fi

    garbagecollect_list "$target" "$recipe" "$garbagecollectdays" |
    sed -e 's|^|rm -rf |' |
    bash
}

print_info_openblock()
{
    HEADLINEPRINTED=0
}

print_info_headline()
{
    if test "$HEADLINEPRINTED" = 0; then
        echo "$@"
        HEADLINEPRINTED=1
    fi
}

print_info_closeblock()
{
    if test "$HEADLINEPRINTED" = 1; then
        echo
    fi
}

print_info_matchprint()
{
    local T1
    local PKG
    local MATCH="$1"
    shift

    print_info_openblock
    while read T1 PKG; do
        if test "$T1" = "$MATCH"; then
            print_info_headline "$@"
            echo "    $PKG"
        fi
    done < $FILE
    print_info_closeblock
}

print_info()
{
    local T1
    local T2
    local PKG
    local RELOC
    local HEADLINEPRINTED
    local FILE="$1"

    print_info_openblock
    while read T1 PKG; do
	if test "$T1" = '#|info'; then
	    if test "$HEADLINEPRINTED" = 0; then
		HEADLINEPRINTED=1
	    fi
	    echo "$PKG"
	fi
    done < $FILE
    print_info_closeblock

    print_info_openblock
    local FORMATPRINTED=1
    while read T1 T2 PKG RELOC; do
        if test "$T1" = '#|pkg'; then
            case "$T2" in
                name)
                    if test "$FORMATPRINTED" = 0; then
                        echo ".$DEFAULTFORMAT"
                    fi
                    if test "$PKG" = nopackage; then
                        FORMATPRINTED=1
                    else
                        print_info_headline created packages:
                        echo -n "    $PKG"
                        FORMATPRINTED=0
                    fi
                    ;;
                format)
                    echo ".$PKG"
                    FORMATPRINTED=1
                    ;;
            esac
        fi
    done < $FILE
    if test "$FORMATPRINTED" = 0; then
        echo ".$DEFAULTFORMAT"
    fi
    print_info_headline no packages created.
    print_info_closeblock

    print_info_openblock
    while read T1 PKG RELOC; do
        if test "$T1" = '#|dep' && test "$PKG" != auto; then
            print_info_headline explicit direct build dependencies on other builds:
            echo "    $PKG $RELOC"
        fi
    done < $FILE
    print_info_closeblock

    print_info_matchprint '#|ins' 'direct build dependencies on other artifacts:'
    print_info_matchprint '#|blk' 'locked build dependencies on other artifacts:'
    print_info_matchprint '#|blkbase' 'locked build dependencies on other artifacts from other builds:'
}

recipe=all
target=all
varset=0
nodeps=0
dirty=
force=0
release=
onlypublish=0
buildinternal=0
progress=100
prepopulate=link
prepopulatespec=0
purgepool=0
keepbuilds=
purgebuilds=0
verbose=
whattodo=build
garbagecollectdays=60

if test -r "$base/.buildrc/pkgpool"; then
    PKGPOOL=$(< "$base/.buildrc/pkgpool")
elif test -r "$srcbase/.buildrc/pkgpool"; then
    PKGPOOL=$(< "$srcbase/.buildrc/pkgpool")
else
    PKGPOOL=~/pkgpool
fi
if test -r "$base/.buildrc/releaseuser"; then
    releaseuser=$(< "$base/.buildrc/releaseuser")
elif test -r "$srcbase/.buildrc/releaseuser"; then
    releaseuser=$(< "$srcbase/.buildrc/releaseuser")
else
    releaseuser="$(id -un)"
fi

while test $# -gt 0; do
    case "$1" in
	-j)
	    parallel="-j$2"
	    shift
	    ;;
	-j*)
	    parallel="$1"
	    ;;
	--release)
	    release="$2"
	    shift
	    ;;
	--release=*)
	    release="${1/--release=}"
	    ;;
	--writecache)
	    release=.
	    ;;
	--publish-internal)
	    onlypublish=1
	    release="$2"
	    shift
	    ;;
	--build-internal)
	    nodeps=1
	    buildinternal=1
	    parallel=
	    ;;
	--progress)
	    progress="$2"
	    shift
	    ;;
	--progress=*)
	    progress="${1/--progress=}"
	    ;;
	--prepopulate|--prepopulate=yes|--prepopulate=link)
	    prepopulate=link
	    prepopulatespec=1
	    ;;
	--no-prepopulate|--prepopulate=no)
	    prepopulate=no
	    prepopulatespec=1
	    ;;
	--prepopulate=copy)
	    prepopulate=copy
	    prepopulatespec=1
	    ;;
	--force)
	    force=recipe
	    ;;
	--force-target)
	    force=target
	    ;;
	--force-all)
	    force=all
	    ;;
	--nodeps)
	    nodeps=1
	    ;;
	--dirty)
	    dirty=--dirty
	    ;;
	--purgepool)
	    purgepool=1
	    ;;
	--keepbuilds)
	    keepbuilds=--keepbuilds
	    ;;
	--purgebuilds)
	    purgebuilds=1
	    ;;
	--verbose)
	    verbose=--verbose
	    ;;
	--resolve-ins)
	    whattodo=resolve_ins
	    ;;
	--info)
	    whattodo=info
	    ;;
	--garbagecollect)
	    whattodo=garbagecollect
	    ;;
	--garbagecollect=*)
	    whattodo=garbagecollect
	    garbagecollectdays="${1/--garbagecollect=}"
	    ;;
	--garbagecollect-list)
	    whattodo=garbagecollect-list
	    ;;
	--garbagecollect-list=*)
	    whattodo=garbagecollect-list
	    garbagecollectdays="${1/--garbagecollect-list=}"
	    ;;
	--pkgpool)
	    PKGPOOL="$2"
	    shift
	    ;;
	--pkgpool=*)
	    PKGPOOL="${1/--pkgpool=}"
	    ;;
	--releaseuser)
	    releaseuser="$2"
	    shift
	    ;;
	--releaseuser=*)
	    releaseuser="${1/--releaseuser=}"
	    ;;
	--listrecipes)
	    listpkgs
	    exit 0
	    ;;
	--listtargets)
	    listarchs
	    exit 0
	    ;;
	--noperl)
	    haveperl=
	    ;;
	--help)
	    cat <<EOT
Usage: build [options] [recipe] [target]
Options:
  -j [N]                      Allow N jobs at once.
  --force                     Force rebuild of selected recipe, even when in
                              clean state.
  --force-target              Force rebuild of all recipes on selected target,
                              even when in clean state.
  --force-all                 Force rebuild of all recipes, even when in clean
                              state.
  --nodeps                    Rebuild mentioned recipe on target ignoring any
                              dependencies.
  --dirty                     Also consider changes not yet committed for
                              builds.
  --verbose                   Be verbose, even when there is no error.
  --prepopulate=yes|no|copy|link   Pre-populate build results from the build
                              cache using link mode (yes|link) or copy mode
                              (copy).  If no is specified do not prepopulate.
  --keepbuilds                Keep all build working directories after
                              successfully completing the builds.
  --purgebuilds               Purge all build working directories before
                              starting the builds.
  --purgepool                 Purge obsolete binaries before the builds.
  --release [PREFIX]          Publish build results under PREFIX.
  --writecache                Publish build results into build cache.
  --pkgpool [DIR]             Directory of alternative package pool.
  --releaseuser [USER]        User name of release user with elevated
                              priviliges.
  --info                      Print information about specified recipe.
  --listrecipes               List available recipes and exit.
  --listtargets               List available targets and exit.
  --help                      Print this message and exit.

Report bugs to <$BUGMAIL>
EOT
	    exit 0
	    ;;
	-*)
	    logerr "Unknown option $1.  Try --help."
	    exit 1
	    ;;
	*)
	    case $varset in
		0)
		    varset=1
		    recipe="$1"
		    ;;
		1)
		    varset=2
		    target="$1"
		    ;;
		2)
		    logerr 'Too many parameters.'
		    exit 1
		    ;;
	    esac
	    ;;
    esac
    shift
done

if test "$release" -a "$dirty"; then
    logerr Specifying --dirty together with --release or --writecache is not allowed.
    exit 1
fi

case "$PKGPOOL" in
    /*) ;;
    *) PKGPOOL="$PWD/$PKGPOOL" ;;
esac

if test -x build && test "$(stat -c '%m/%i' build)" = "$(stat -c '%m/%i' $0)"; then
    outofplace=0
else
    outofplace=1
    if test ! -r .buildmark; then
	if test $(find . | head -n 2 | wc -l) != 1; then
	    logerr Only use on top level of existing build directory or empty one.
	    exit 1
	fi
    fi
fi

mkdir -p "$states"
if test $prepopulatespec = 0 -a -r $states/_prepopulate; then
    prepopulate=$(cat $states/_prepopulate)
else
    echo "$prepopulate" > $states/_prepopulate
fi

test "$prepopulate" = link && prepopulatebin="ln -s" || prepopulatebin="cp"

recipesum=$( (echo 2 && ls $recipes | LC_ALL=C sort -u && cat $(ls $recipes/* | LC_ALL=C sort -u)) | sha1sum | sed -e 's| .*||')

if test "$onlypublish" = 1; then
    publish "$release"
    exit 0
fi

if test $outofplace = 1 -a $buildinternal != 1; then
    touch .buildmark
    for tool in build repo; do
	if test ! -x $tool; then
	    rm -f $tool
	    cat <<EOT > $tool
#!/bin/bash
exec $(dirname $0)/$tool "\$@"
EOT
	    chmod 755 $tool
	fi
    done
    for tool in recipes src; do
	if test ! -d $tool; then
	    rm -f $tool
	    ln -s $(dirname $0)/$tool $tool
	fi
    done
fi


test "$purgebuilds" = 1 && purgebuilds || true

if test "$whattodo" = resolve_ins; then
    mkdir -p $tmp
    file=$(getrecipe $recipe $target)
    if test "$file" = ""; then
        logerr "Nothing known about $recipe on $target."
        exit 1
    fi
    resolve_ins 0 < $file
    forcerm $tmp
    exit 0
fi

if test "$whattodo" = info; then
    file=$(getrecipe $recipe $target)
    if test "$file" = ""; then
        logerr "Nothing known about $recipe on $target."
        exit 1
    fi
    print_info $file
    exit 0
fi

if test "$whattodo" = garbagecollect; then
    garbagecollect "$target" "$recipe" "$garbagecollectdays"
    exit 0
fi

if test "$whattodo" = garbagecollect-list; then
    garbagecollect_list "$target" "$recipe" "$garbagecollectdays"
    exit 0
fi

case "$force" in
    recipe) forcerm "$states/$target/$recipe";;
    target) forcerm "$states/$target";;
    all)    forcerm "$states";;
esac

if test $nodeps = 1; then
    invoke "$recipe" "$target"
else
    makefilesum=$(sed -ne 's|^##RECIPESUM## ||p' "$states/_depmake" 2>/dev/null || true)
    if test "$recipesum" != "$makefilesum"; then
	pkghash=$(echo $recipesum | sed -e 's|^\([0-9a-f][0-9a-f]\)\([0-9a-f]*\)$|_depmake/\1/\2|')
	rm -f "$states/_depmake"
	if test "$prepopulate" != no -a -r "$PKGPOOL/.hashpool/$pkghash/_depmake"; then
	    logmsg Retrieving dependencies
	    mkdir -p $states
	    $prepopulatebin "$PKGPOOL/.hashpool/$pkghash/_depmake" "$states/"
	else
	    logmsg Calculating dependencies
	    rm -f $states/*/*/depchk
	    calcdeps > "$states/_depmake"
	    echo "##RECIPESUM## $recipesum" >> "$states/_depmake"
	    rm -f $states/*/*/depchk
	fi
    fi
    test "$release" && publishdepmake || true
    for pkgiter in $(sed -ne 's|^_PKG/\(.*\): .* #GEN$|\1|p' states/_depmake |
		     sort | uniq -d); do
	logerr "WARNING: $pkgiter is generated by multiple recipes and targets:"
	sed -ne "s|^_PKG/\($pkgiter\): \(.*\)/\(.*\)|WARNING:         \3 \2|p" states/_depmake |
	while read line; do
	    logerr "$line"
	done
    done
    test "$purgepool" = 1 && purgepool || true
    if test "$haveperl"; then
	"$src/buildtool/extract_dependencies" "$recipe" "$states/_depmake"
    else
	cat "$states/_depmake"
    fi > "$states/_depmake_tmp"
    make $parallel -f "$states/_depmake_tmp" --no-print-directory \
	BUILD="$0 --prepopulate=$prepopulate $dirty $keepbuilds $verbose --pkgpool=$PKGPOOL" "$target/$recipe"
    rm "$states/_depmake_tmp"
fi

test "$release" && publish "$release" || true

if test $buildinternal != 1; then
    logmsg done.
fi
